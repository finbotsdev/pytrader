#!/usr/bin/env python
# -*- coding: utf-8 -*-

import ast
from crontab import CronTab
import csv
import datetime as dt
import getpass
import os
import pytrader as pt
from pytrader.data import AlpacaMarkets, AlpacaStream, YahooFinance, date
from pytrader.log import logger
import pytrader.screener as screener
import re
import sqlalchemy as sa
from sqlalchemy import exc
import traceback

from model import Session
from model.asset import Asset
from model.ohlcv import Ohlcv


"""
  pytrade
  ------
  a cli interface to pytrader
"""


"""
  backtest strategy runner
  ------
  execute selected strategy script
"""
def backtest_cmd(args):
  logger.debug('pytrader backtest')
  logger.debug(args)
  os.system(f'python backtest/{args.strategy}.py')


"""
  bars
  ------

"""
def get_chunk_bars(symbol, end, start):
  logger.debug(f'fetch_range_bars {symbol}: {type(symbol)} {end}: {type(end)} {start}: {type(start)}')
  # convert string dates to datetime objects

  fds, dstart = date(start)
  eds, dend = date(end)
  # get count of days between start and end date
  days_remaining = abs(dend-dstart).days

  api = AlpacaMarkets()

  # fetch bar data in week sized chunks
  bars = []
  while days_remaining > 0:
    start = days_remaining
    end = days_remaining -7
    days_remaining = days_remaining - 8

    sds, dstart = date(f'{start} days ago')
    eds, dend = date(f'{end} days ago')

    result = api.get_bars(symbol, end=eds, start=sds, timeframe='1Min', limit=10000)
    if result and result['bars']:
      count = len(result['bars'])
      res = result['bars']
    else:
      res = []
    logger.info(f'{symbol} - {sds} to {eds} - {len(res)} bars returned')

    bars.extend(res)

  logger.info(f'{dstart} to {dend} - {len(bars)} minute bars')
  return bars

def bars_cmd(args):
  logger.debug('pytrader history')
  logger.debug(args)

  session = Session()

  logger.info('get assets list from local db')
  query = session.query(Asset).filter(
    Asset.status == 'active',
    Asset.is_tradeable == True)

  if args.tickers:
    query = query.filter(Asset.symbol.in_(args.tickers))

  assets = query.all()

  for asset in assets:
    bars = get_chunk_bars(asset.symbol, end=args.end, start=args.start)
    for b in bars:
      try:
        logger.info(f"create ohlcv for {asset.symbol} {b['t']} ")
        session.add(Ohlcv(
          asset_id=asset.id,
          period='minute',
          dt=b['t'],
          open=b['o'],
          high=b['h'],
          low=b['l'],
          close=b['c'],
          volume=b['v']
        ))
        session.commit()

      except Exception as e:
        session.rollback()
        logger.error(e)
        print(e)

  num_prices = session.query(Ohlcv).count()
  logger.info(f"{num_prices} ohlcv records exist in the database")


"""
  crontab
  ------
  update crontab for pytrader
"""
def crontab_cmd(_):
  logger.debug('pytrader crontab')
  logger.debug(args)

  current_user = getpass.getuser()
  cwd = os.getcwd()
  cron = CronTab(user=current_user)

  logger.info('cron list before')
  for job in cron:
    print(job)

  # remove all pytrader cron jobs
  cron.remove_all(comment='pytrader')

  # sync exchanges at 6:05 am
  comment = f'pytrader'
  cmd = f'cd {cwd}; ./cronjob ./pytrade sync -r exchanges'
  job = cron.new(command=cmd, comment=comment)
  job.hour.every(1)
  job.hour.every(6)
  job.minute.on(5)

  # sync assets at 6:15 am
  comment = f'pytrader'
  cmd = f'cd {cwd}; ./cronjob ./pytrade sync -r assets'
  job = cron.new(command=cmd, comment=comment)
  job.hour.every(1)
  job.hour.every(6)
  job.minute.on(10)

  # # sync etf holdings at 8:05 pm
  # comment = f'pytrader'
  # cmd = f'cd {cwd}; ./cronjob ./pytrade sync -r etfholding'
  # job = cron.new(command=cmd, comment=comment)
  # job.dow.on('MON', 'TUE', 'WED', 'THU', 'FRI')
  # job.hour.every(20)
  # job.minute.on(10)

  # # sync prices daily at 8:10 pm
  # comment = f'pytrader'
  # cmd = f'cd {cwd}; ./cronjob ./pytrade bars'
  # job = cron.new(command=cmd, comment=comment)
  # job.dow.on('MON', 'TUE', 'WED', 'THU', 'FRI')
  # job.hour.every(20)
  # job.minute.on(15)

  # # sync redit mentions every hour
  # comment = f'pytrader'
  # cmd = f'cd {cwd}; ./cronjob ./pytrade sync -r wallstreetbets'
  # job = cron.new(command=cmd, comment=comment)
  # job.hour.every(1)
  # job.minute.on(0)

  cron.write()

  logger.info('cron list after')
  for job in cron:
    print(job)


"""
  download
  ------
  download historical data for assets
"""
def download_cmd(args):
  logger.debug('pytrader download')
  logger.debug(args)

  end = args.end
  interval = args.interval
  start = args.start
  tickers = args.tickers

  api = YahooFinance()
  session = Session()

  if not tickers: # if no tickers provided fetch all from database
    assets = session.query(Asset.symbol).filter(
      Asset.status == 'active',
      Asset.is_tradeable == True
    ).all()
    tickers = [a.symbol for a in assets]

  intervals = { # map patam interval to what yfinance expects
    'minute': '1m',
    'day': '1d'
  }

  for s in tickers: # iterate tickers and fetch historical data
    logger.info(f'fetching market data ({interval}) for {s} beginning {start} and ending {end}')
    for ticker in tickers:
      api.set_symbol(ticker)
      df = api.history(end = date(args.end), interval = intervals[args.interval], start = date(args.start) )
      os.makedirs(f'./.data/{interval}', exist_ok=True)
      df.to_csv(f'./.data/{interval}/{s}.csv')


"""
  screener
  ------
  query symbols to watch using stored procedure queries

  usage:
  ------
  tickers=$(pytrade screener); echo $tickers
"""
def screener_cmd(args):
  logger.debug('pytrader screener')
  logger.debug(args)

  strategy = args.strategy

  logger.debug(f'fetching symbols to watch using strategy {strategy}')
  search = screener.Search(strategy)
  symbols = search.symbols()
  print(" ".join(symbols))


"""
  stream
  ------
"""
def stream_cmd(args):
  logger.debug('pytrader stream')
  logger.debug(args)

  ws = AlpacaStream()
  ws.set_tickers(args.tickers)
  ws.run()


"""
  sync
  ------

"""
def sync_cmd(_):
  logger.debug('pytrader assets')
  logger.debug(args)
  os.system(f'python sync/{args.resource}.py')


"""
  version
  ------
  display version information
"""
def version_cmd(args):
  logger.debug('pytrader version')
  logger.debug(args)

  _version_re = re.compile(r'__version__\s+=\s+(.*)')
  with open('pytrader/__init__.py', 'rb') as f:
      version = str(ast.literal_eval(_version_re.search(
          f.read().decode('utf-8')).group(1)))
  print(f'pytrader library version {version}')


def main(args):
  try:
    subcommands = {
      'crontab' : crontab_cmd,
      'backtest' : backtest_cmd,
      'bars' : bars_cmd,
      'download' : download_cmd,
      'screener' : screener_cmd,
      'stream' : stream_cmd,
      'sync' : sync_cmd,
      'version' : version_cmd,
    }
    subcommands[args.subcommand](args)

  except Exception as e:
    logger.error(e)
    print(e)
    print(traceback.format_exc())


if __name__ == '__main__':
  parser = pt.ArgumentParser()
  parser.add_argument("-v", "--verbose", action='store_true', help="verbose")

  subparsers = parser.add_subparsers(dest="subcommand") # this line changed
  subparsers.required = True

  mention_parser = subparsers.add_parser('backtest')
  mention_parser.add_argument('-s', '--strategy', default='openbreakout', help="the strategy" )
  mention_parser.add_argument('-t', '--ticker', default=[], help="the ticker symbol" )

  bars_parser = subparsers.add_parser('bars')
  bars_parser.add_argument("-e", "--end", default="yesterday", help="earliest date to include")
  bars_parser.add_argument("-s", "--start", default="5 years ago", help="latest date to include")
  bars_parser.add_argument('-t', '--tickers', default=[], help="list of ticker symbols to include", nargs='+' )

  crontab_parser = subparsers.add_parser('crontab')

  download_parser = subparsers.add_parser('download')
  download_parser.add_argument("-e", "--end", default="yesterday", help="earliest date to include")
  download_parser.add_argument("-i", "--interval", default="day", help="market data aggregation level (day or minute)")
  download_parser.add_argument("-s", "--start", default="5 years ago", help="latest date to include")
  download_parser.add_argument('-t', '--tickers', default=[], help="list of ticker symbols to include", nargs='+' )

  etf_parser = subparsers.add_parser('etfholdings')

  screener_parser = subparsers.add_parser('screener')
  screener_parser.add_argument('-s', '--strategy', default='s&p500', help="the strategy filter to use for the screener" )

  stream_parser = subparsers.add_parser('stream')
  stream_parser.add_argument('-t', '--tickers', default=[], help="list of ticker symbols to include", nargs='+' )

  sync_parser = subparsers.add_parser('sync')
  sync_parser.add_argument('-r', '--resource', default='stock', help="resource type to sync" )

  screener_parser = subparsers.add_parser('version')

  args = parser.parse_args()

  timer = pt.Timer()
  logger.info('pytrader cli tool')
  main(args)
  timer.report()
