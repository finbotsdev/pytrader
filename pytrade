#!/usr/bin/env python
# -*- coding: utf-8 -*-

import ast
import config
from crontab import CronTab
import csv
import datetime as dt
import getpass
import os
import pytrader as pt
from pytrader.csv import is_comment, is_whitespace, read_and_filter_csv
from pytrader.data import AlpacaMarkets, date
from pytrader.data import YahooFinance
from pytrader.log import logger
import pytrader.screener as screener
import re
import requests
import sqlalchemy as sa
from sqlalchemy import exc
import traceback

from model import Session
from model.asset import Asset
from model.etf_holding import EtfHolding
from model.price import Price


"""
  pytrade
  ------
  a cli interface to pytrader
"""


"""
  assets
  ------
  maintain asset table in the database
"""
def assets_cmd(_):
  logger.debug('pytrader assets')
  logger.debug(args)

  api = AlpacaMarkets()
  session = Session()

  logger.info('get assets list from exchange')
  assets = api.get_assets()

  for a in assets:
    asset = session.query(Asset).filter(
      Asset.symbol == a['symbol'],
      Asset.exchange == a['exchange']).first()

    if not asset:
      logger.info(f"create record {a['symbol']} - {a['name']}")
      asset = Asset(
        company=a['name'],
        asset_class=a['class'],
        exchange=a['exchange'],
        is_easy_to_borrow=a['easy_to_borrow'],
        is_etf=False,
        is_fractionable=a['fractionable'],
        is_marginable=a['marginable'],
        is_shortable=a['shortable'],
        is_tradeable=a['tradable'],
        status=a['status'],
        symbol=a['symbol'])
      session.add(asset)
    else:
      logger.info(f"update record {a['symbol']} - {a['name']}")
      asset.company=a['name']
      asset.asset_class=a['class']
      asset.exchange=a['exchange']
      asset.is_easy_to_borrow=a['easy_to_borrow']
      asset.is_fractionable=a['fractionable']
      asset.is_marginable=a['marginable']
      asset.is_shortable=a['shortable']
      asset.is_tradeable=a['tradable']
      asset.status=a['status']
      asset.symbol=a['symbol']

    session.commit()

  num_assets = session.query(Asset).count()
  logger.info(f"{num_assets} asset records exist in the database")


"""
  backtest strategy runner
  ------
  execute selected strategy script
"""
def backtest_cmd(args):
  logger.debug('pytrader backtest')
  logger.debug(args)
  os.system(f'python strategies/{args.strategy}.py')


"""
  bars
  ------
"""
def get_chunk_bars(symbol, end, start):
  logger.debug(f'fetch_range_bars {symbol}: {type(symbol)} {end}: {type(end)} {start}: {type(start)}')
  # convert string dates to datetime objects
  dstart = dt.datetime.strptime(date(start), '%Y-%m-%d')
  dend = dt.datetime.strptime(date(end), '%Y-%m-%d')
  # get count of days between start and end date
  days_remaining = abs(dend-dstart).days

  api = AlpacaMarkets()

  # fetch bar data in week sized chunks
  bars = []
  while days_remaining > 0:
    start = days_remaining
    end = days_remaining -7
    days_remaining = days_remaining - 8

    start_date = date(f'{start} days ago')
    end_date = date(f'{end} days ago')

    result = api.get_bars(symbol, end=date(end_date), start=date(start_date), timeframe='1Min', limit=10000)
    if result and result['bars']:
      count = len(result['bars'])
      res = result['bars']
    else:
      res = []
    logger.info(f'{symbol} - {start_date} to {end_date} - {len(res)} bars returned')

    bars.extend(res)

  logger.info(f'{dstart} to {dend} - {len(bars)} minute bars')
  return bars

def bars_cmd(args):
  logger.debug('pytrader history')
  logger.debug(args)

  session = Session()

  logger.info('get assets list from local db')
  query = session.query(Asset).filter(
    Asset.status == 'active',
    Asset.is_tradeable == True)

  if args.tickers:
    query = query.filter(Asset.symbol.in_(args.tickers))

  assets = query.all()

  for asset in assets:
    bars = get_chunk_bars(asset.symbol, end=args.end, start=args.start)
    for b in bars:
      try:
        logger.info(f"create price for {asset.symbol} {b['t']} ")
        session.add(Price(
          asset_id=asset.id,
          period='minute',
          dt=b['t'],
          open=b['o'],
          high=b['h'],
          low=b['l'],
          close=b['c'],
          volume=b['v']
        ))
        session.commit()

      except Exception as e:
        session.rollback()
        logger.error(e)
        print(e)

  num_prices = session.query(Price).count()
  logger.info(f"{num_prices} price records exist in the database")


"""
  crontab
  ------
  update crontab for pytrader
"""
def crontab_cmd(_):
  logger.debug('pytrader crontab')
  logger.debug(args)

  current_user = getpass.getuser()
  cwd = os.getcwd()
  cron = CronTab(user=current_user)

  logger.info('cron list before')
  for job in cron:
    print(job)

  # remove all pytrader cron jobs
  cron.remove_all(comment='pytrader')

  # sync assets at 8:00 pm
  comment = f'pytrader'
  cmd = f'cd {cwd}; ./cronjob ./pytrade assets'
  job = cron.new(command=cmd, comment=comment)
  job.dow.on('MON', 'TUE', 'WED', 'THU', 'FRI')
  job.hour.every(20)
  job.minute.on(0)

  # sync etf holdings at 8:05 pm
  comment = f'pytrader'
  cmd = f'cd {cwd}; ./cronjob ./pytrade etfholdings'
  job = cron.new(command=cmd, comment=comment)
  job.dow.on('MON', 'TUE', 'WED', 'THU', 'FRI')
  job.hour.every(20)
  job.minute.on(5)

  # sync prices daily at 8:10 pm
  comment = f'pytrader'
  cmd = f'cd {cwd}; ./cronjob ./pytrade bars'
  job = cron.new(command=cmd, comment=comment)
  job.dow.on('MON', 'TUE', 'WED', 'THU', 'FRI')
  job.hour.every(20)
  job.minute.on(10)

  # sync redit mentions every hour
  comment = f'pytrader'
  cmd = f'cd {cwd}; ./cronjob ./pytrade mentions'
  job = cron.new(command=cmd, comment=comment)
  job.hour.every(1)
  job.minute.on(0)

  cron.write()

  logger.info('cron list after')
  for job in cron:
    print(job)


"""
  download
  ------
  download historical data for assets
"""
def download_cmd(args):
  logger.debug('pytrader download')
  logger.debug(args)

  end = args.end
  interval = args.interval
  start = args.start
  tickers = args.tickers

  api = YahooFinance()
  session = Session()

  if not tickers: # if no tickers provided fetch all from database
    assets = session.query(Asset.symbol).filter(
      Asset.status == 'active',
      Asset.is_tradeable == True
    ).all()
    tickers = [a.symbol for a in assets]

  intervals = { # map patam interval to what yfinance expects
    'minute': '1m',
    'day': '1d'
  }

  for s in tickers: # iterate tickers and fetch historical data
    logger.info(f'fetching market data ({interval}) for {s} beginning {start} and ending {end}')
    for ticker in tickers:
      api.set_symbol(ticker)
      df = api.history(end = date(args.end), interval = intervals[args.interval], start = date(args.start) )
      os.makedirs(f'./.data/{interval}', exist_ok=True)
      df.to_csv(f'./.data/{interval}/{s}.csv')


"""
  etf holdings
  ------
  grab lists of holdings from various etfs
  maintain a local db of etf holdings so that we can observe changes over time
"""
def etfholdings_cmd(args):
  logger.debug('pytrader etf')
  logger.debug(args)

  session = Session()

  feeds = {
    "ARKK": "https://ark-funds.com/wp-content/fundsiteliterature/csv/ARK_INNOVATION_ETF_ARKK_HOLDINGS.csv",
    "ARKQ": "https://ark-funds.com/wp-content/fundsiteliterature/csv/ARK_AUTONOMOUS_TECHNOLOGY_&_ROBOTICS_ETF_ARKQ_HOLDINGS.csv",
    "ARKW": "https://ark-funds.com/wp-content/fundsiteliterature/csv/ARK_NEXT_GENERATION_INTERNET_ETF_ARKW_HOLDINGS.csv",
    "ARKG": "https://ark-funds.com/wp-content/fundsiteliterature/csv/ARK_GENOMIC_REVOLUTION_MULTISECTOR_ETF_ARKG_HOLDINGS.csv",
    "ARKF": "https://ark-funds.com/wp-content/fundsiteliterature/csv/ARK_FINTECH_INNOVATION_ETF_ARKF_HOLDINGS.csv",
    "ARKX": "https://ark-funds.com/wp-content/fundsiteliterature/csv/ARK_SPACE_EXPLORATION_&_INNOVATION_ETF_ARKX_HOLDINGS.csv",
    "IZRL": "https://ark-funds.com/wp-content/fundsiteliterature/csv/ARK_ISRAEL_INNOVATIVE_TECHNOLOGY_ETF_IZRL_HOLDINGS.csv",
    "PRNT": "https://ark-funds.com/wp-content/fundsiteliterature/csv/THE_3D_PRINTING_ETF_PRNT_HOLDINGS.csv",
  }

  today = dt.date.today().strftime('%Y-%m-%d')
  etf_symbols = [key for key in feeds]

  for asset in session.query(Asset).filter(Asset.symbol.in_(etf_symbols)):
    asset.is_etf = True
  session.commit()

  for etf in session.query(Asset).filter(Asset.is_etf == True):
    logger.info(f"Download Holdings Report for {etf.company} ({etf.symbol})")

    # create directory to store download files
    dirname = os.path.dirname(__file__)
    filepath = os.path.join(dirname, '.data', 'holdings', today)
    os.path.dirname(__file__)
    os.makedirs(filepath, exist_ok=True)

    # download updated csv file for fund
    if etf.symbol in feeds.keys():
      url = feeds[etf.symbol]
      logger.info(f"    {url}")

      hfile = f"{filepath}/ETF_{etf.symbol}_HOLDINGS.csv"

      headers = {
        'User-Agent': 'AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.114 Safari/537.36',
      }

      with requests.get(url, headers=headers, stream=True) as r:
        r.raise_for_status()
        with open(hfile, 'wb') as f:
          for chunk in r.iter_content(chunk_size=8192):
            f.write(chunk)

      try:
        for l in read_and_filter_csv(hfile, is_comment, is_whitespace):
          if l['date'] and l['ticker'] and l['shares'] and l['weight(%)']:
            holding = session.query(Asset).filter(Asset.symbol == l['ticker']).first()
            if holding:
              logger.info(f"    {etf.symbol} holds {l['shares']} shares of {holding.symbol} which is {l['weight(%)']}% of their holdings")
              eft_holding = EtfHolding(
                etf_id=etf.id,
                holding_id=holding.id,
                dt=l['date'],
                shares=l['shares'],
                weight=l['weight(%)'],
              )
              session.add(eft_holding)
        session.commit()
      except Exception as e:
        session.rollback()
        logger.error(e)
        print(e)

    else:
        logger.info(f"{etf.symbol} does not exist in feeds dict")

"""
  mentions
  ------
"""
def mentions_cmd(args):
  logger.debug('pytrader mention')
  logger.debug(args)
  os.system(f'python mentions/{args.strategy}.py')


"""
  screener
  ------
  query symbols to watch using stored procedure queries

  usage:
  ------
  tickers=$(pytrade screener); echo $tickers
"""
def screener_cmd(args):
    logger.debug('pytrader screener')
    logger.debug(args)

    strategy = args.strategy

    logger.debug(f'fetching symbols to watch using strategy {strategy}')
    search = screener.Search(strategy)
    symbols = search.symbols()
    print(" ".join(symbols))


"""
  watch
  ------
"""
def watch_cmd(args):
    logger.debug('pytrader watch')
    logger.debug(args)


"""
  version
  ------
  display version information
"""
def version_cmd(args):
    logger.debug('pytrader version')
    logger.debug(args)

    _version_re = re.compile(r'__version__\s+=\s+(.*)')
    with open('pytrader/__init__.py', 'rb') as f:
        version = str(ast.literal_eval(_version_re.search(
            f.read().decode('utf-8')).group(1)))
    print(f'pytrader library version {version}')


def main(args):
  try:
    subcommands = {
        'assets' : assets_cmd,
        'crontab' : crontab_cmd,
        'backtest' : backtest_cmd,
        'bars' : bars_cmd,
        'download' : download_cmd,
        'etfholdings' : etfholdings_cmd,
        'mentions' : mentions_cmd,
        'screener' : screener_cmd,
        'watch' : watch_cmd,
        'version' : version_cmd,
    }
    subcommands[args.subcommand](args)

  except Exception as e:
    logger.error(e)
    print(e)
    print(traceback.format_exc())


if __name__ == '__main__':
  parser = pt.ArgumentParser()
  parser.add_argument("-v", "--verbose", action='store_true', help="verbose")

  subparsers = parser.add_subparsers(dest="subcommand") # this line changed
  subparsers.required = True

  assets_parser = subparsers.add_parser('assets')

  mention_parser = subparsers.add_parser('backtest')
  mention_parser.add_argument('-s', '--strategy', default='openbreakout', help="the strategy" )
  mention_parser.add_argument('-t', '--ticker', default=[], help="the ticker symbol" )

  bars_parser = subparsers.add_parser('bars')
  bars_parser.add_argument("-e", "--end", default="yesterday", help="earliest date to include")
  bars_parser.add_argument("-s", "--start", default="5 years ago", help="latest date to include")
  bars_parser.add_argument('-t', '--tickers', default=[], help="list of ticker symbols to include", nargs='+' )

  crontab_parser = subparsers.add_parser('crontab')

  download_parser = subparsers.add_parser('download')
  download_parser.add_argument("-e", "--end", default="yesterday", help="earliest date to include")
  download_parser.add_argument("-i", "--interval", default="day", help="market data aggregation level (day or minute)")
  download_parser.add_argument("-s", "--start", default="5 years ago", help="latest date to include")
  download_parser.add_argument('-t', '--tickers', default=[], help="list of ticker symbols to include", nargs='+' )

  etf_parser = subparsers.add_parser('etfholdings')

  mention_parser = subparsers.add_parser('mentions')
  mention_parser.add_argument('-s', '--strategy', default='wallstreetbets', help="the strategy" )

  screener_parser = subparsers.add_parser('screener')
  screener_parser.add_argument('-s', '--strategy', default='s&p500', help="the strategy filter to use for the screener" )

  watch_parser = subparsers.add_parser('watch')

  screener_parser = subparsers.add_parser('version')

  args = parser.parse_args()

  timer = pt.Timer()
  logger.info('pytrader cli tool')
  main(args)
  timer.report()

